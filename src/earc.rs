use std::{
    any::{Any, TypeId},
    collections::{HashMap, VecDeque},
    marker::PhantomData,
    pin::Pin,
    sync::{Arc, RwLock, Weak},
    task::{Context, Poll, Waker},
};

use futures::{
    task::{Spawn, SpawnError, SpawnExt},
    Stream, StreamExt,
};

/// Reference-counting object based on Arc<RwLock<...>> with methods for broadcasting events
#[derive(Clone)]
pub struct EArc {
    waker: Arc<RwLock<Option<Waker>>>,
    subscribers: Weak<RwLock<Subscribers>>,
    pending_queue: Weak<RwLock<PendingQueue>>,
}

/// Non-owning reference to EArc
#[derive(Clone)]
pub struct WEArc {
    waker: Weak<RwLock<Option<Waker>>>,
    subscribers: Weak<RwLock<Subscribers>>,
    pending_queue: Weak<RwLock<PendingQueue>>,
}

struct SEArc {
    waker: Weak<RwLock<Option<Waker>>>,
    subscribers: Arc<RwLock<Subscribers>>,
    pending_queue: Arc<RwLock<PendingQueue>>,
    pending_event: Weak<EventBox>,
}

/// Container for event. The main purpose of this container is to ensure correct order of events.
/// All events to be broadcasted to subscribers by ['EArc'] object are placed to queue first and broadcased wrapped to Arc<Event>.
/// No next event is broadcasted until previous Event is dropped. So new event is sent to subscribers only when all subscribers
/// confirms that they finished processing of previous event (by dropping their copy of Arc<EventBox>)
pub struct Event<EVT: 'static + Send + Sync> {
    event_box: Arc<EventBox>,
    _phantom: PhantomData<EVT>,
}

/// Asychronous stream of events of specified type generated by EArc object. The stream's next() method returns Some(Event<EVT>) while
/// source object EArc is alive and None when EArc is destroyed.
pub struct EventStream<EVT: Send + Sync + 'static> {
    event_queue: Arc<RwLock<EventBoxQueue>>,
    _phantom: PhantomData<EVT>,
}

struct EventBox {
    event_id: TypeId,
    event: Box<dyn Any + Send + Sync>,
    waker: RwLock<Option<Waker>>,
}

type EventBoxQueue = EventQueue<Arc<EventBox>>;
type PendingQueue = EventQueue<(TypeId, Box<dyn Any + Send + Sync>)>;

struct EventQueue<EVT: Send + Sync> {
    detached: bool,
    waker: Option<Waker>,
    events: VecDeque<EVT>,
}

struct EventSubscribers {
    event_subscribers: Vec<Weak<RwLock<EventBoxQueue>>>,
}

struct Subscribers {
    subscribers: HashMap<TypeId, EventSubscribers>,
}

impl Drop for EventBox {
    fn drop(&mut self) {
        if let Some(waker) = self.waker.write().unwrap().take() {
            waker.wake()
        }
    }
}

impl EventBox {
    fn new(event_id: TypeId, event: Box<dyn Any + Send + Sync>, waker: Waker) -> Self {
        Self {
            event_id,
            event,
            waker: RwLock::new(Some(waker)),
        }
    }
    pub fn get_event_id(&self) -> TypeId {
        self.event_id
    }
    pub fn get_event<EVT: 'static + Send + Sync>(&self) -> Option<&EVT> {
        self.event.downcast_ref()
    }
}

impl<EVT: Send + Sync> EventQueue<EVT> {
    fn new() -> Self {
        Self {
            detached: false,
            waker: None,
            events: VecDeque::new(),
        }
    }
    fn is_detached(&self) -> bool {
        self.detached
    }
    fn detach(&mut self) {
        self.detached = true;
        self.wake();
    }
    fn wake(&mut self) {
        self.waker.take().map(|w| w.wake());
    }
    fn set_waker(&mut self, waker: Waker) {
        self.waker = Some(waker)
    }
    fn send_event(&mut self, event: EVT) {
        self.events.push_back(event);
        if let Some(waker) = self.waker.take() {
            waker.wake();
        }
    }
    fn get_event(&mut self) -> Option<EVT> {
        self.events.pop_front()
    }
}

impl Drop for EventSubscribers {
    fn drop(&mut self) {
        self.event_subscribers.iter().for_each(|w| {
            w.upgrade().map(|w| w.write().ok().map(|mut w| w.detach()));
        })
    }
}

impl EventSubscribers {
    fn new() -> Self {
        Self {
            event_subscribers: Vec::new(),
        }
    }
    #[allow(dead_code)]
    fn count(&self) -> usize {
        self.event_subscribers
            .iter()
            .filter(|w| w.strong_count() > 0)
            .count()
    }
    fn subscribe(&mut self, event_queue: Weak<RwLock<EventBoxQueue>>) {
        if let Some(empty) = self
            .event_subscribers
            .iter_mut()
            .find(|w| w.strong_count() == 0)
        {
            *empty = event_queue;
        } else {
            self.event_subscribers.push(event_queue);
        };
    }
    fn send_event(&mut self, event: Arc<EventBox>) {
        self.event_subscribers
            .iter()
            .filter_map(|event_queue| event_queue.upgrade())
            .for_each(|event_queue| {
                event_queue.write().unwrap().send_event(event.clone());
            });
    }
}

impl Subscribers {
    fn new() -> Self {
        Self {
            subscribers: HashMap::new(),
        }
    }
    fn subscribe(&mut self, event_id: TypeId, event_queue: Weak<RwLock<EventBoxQueue>>) {
        let event_subscribers = self
            .subscribers
            .entry(event_id)
            .or_insert(EventSubscribers::new());
        event_subscribers.subscribe(event_queue)
    }
    fn send_event(&mut self, event: Arc<EventBox>) {
        if let Some(event_subscribers) = self.subscribers.get_mut(&event.get_event_id()) {
            event_subscribers.send_event(event)
        }
    }
}

impl<EVT: 'static + Send + Sync> Event<EVT> {
    fn new(event_box: Arc<EventBox>) -> Self {
        Self {
            event_box,
            _phantom: PhantomData,
        }
    }
}

impl<EVT: 'static + Send + Sync> AsRef<EVT> for Event<EVT> {
    fn as_ref(&self) -> &EVT {
        &self.event_box.get_event().unwrap()
    }
}

impl EArc {
    pub fn new(pool: impl Spawn) -> Result<Self, SpawnError> {
        let (mut searc, waker) = SEArc::new();
        let earc = EArc {
            waker,
            subscribers: Arc::downgrade(&searc.subscribers),
            pending_queue: Arc::downgrade(&searc.pending_queue),
        };
        pool.spawn(async move {
            while let Some(event) = searc.next().await {
                searc.retranslate_event(event);
            }
        })?;
        Ok(earc)
    }
    fn subscribe(&self, event_id: TypeId, event_queue: Weak<RwLock<EventBoxQueue>>) {
        self.subscribers
            .upgrade()
            .unwrap()
            .write()
            .unwrap()
            .subscribe(event_id, event_queue)
    }
    pub fn send_event<EVT: Send + Sync + 'static>(&self, event: EVT) {
        self.pending_queue
            .upgrade()
            .unwrap()
            .write()
            .unwrap()
            .send_event((TypeId::of::<EVT>(), Box::new(event)))
    }
    pub fn downgrade(&self) -> WEArc {
        WEArc {
            waker: Arc::downgrade(&self.waker),
            subscribers: self.subscribers.clone(),
            pending_queue: self.pending_queue.clone(),
        }
    }
}

impl Drop for EArc {
    fn drop(&mut self) {
        if let Some(waker) = self.waker.write().unwrap().take() {
            waker.wake()
        }
    }
}

impl<EVT: Send + Sync> Drop for EventQueue<EVT> {
    fn drop(&mut self) {
        if let Some(waker) = self.waker.take() {
            waker.wake()
        }
    }
}

impl WEArc {
    pub fn upgrade(&self) -> Option<EArc> {
        if let Some(waker) = self.waker.upgrade() {
            Some(EArc {
                waker,
                subscribers: self.subscribers.clone(),
                pending_queue: self.pending_queue.clone(),
            })
        } else {
            None
        }
    }
}

impl SEArc {
    fn new() -> (Self, Arc<RwLock<Option<Waker>>>) {
        let waker = Arc::new(RwLock::new(None));
        let subscribers = Arc::new(RwLock::new(Subscribers::new()));
        let pending_queue = Arc::new(RwLock::new(PendingQueue::new()));
        let searc = Self {
            waker: Arc::downgrade(&waker),
            subscribers,
            pending_queue,
            pending_event: Weak::new(),
        };
        (searc, waker)
    }

    fn poll_next(self: &mut Self, cx: &mut Context<'_>) -> Poll<Option<Arc<EventBox>>> {
        // Update waker for pending events queue - waked when event is sent through EArc
        self.pending_queue
            .write()
            .unwrap()
            .set_waker(cx.waker().clone());
        let drop_waker = self.waker.upgrade();
        if let Some(ref drop_waker) = drop_waker {
            // Update waker for earc object itself (if it's still alive) - waked when all colies of EArc is dropped
            *drop_waker.write().unwrap() = Some(cx.waker().clone());
        }
        if let Some(pending_event) = self.pending_event.upgrade() {
            // Update waker for pending event - waked when translated event is dropped by all
            // subscribers.
            *pending_event.waker.write().unwrap() = Some(cx.waker().clone());
            // Translated event is not dropped yet, do not process other events in queue
            return Poll::Pending;
        }
        let event = self.pending_queue.write().unwrap().get_event();
        if let Some((event_id, event)) = event {
            // If queue is not empty, process it - all messages must be delivered
            let event = Arc::new(EventBox::new(event_id, event, cx.waker().clone()));
            self.pending_event = Arc::downgrade(&event);
            Poll::Ready(Some(event))
        } else {
            // Queue is empty
            if drop_waker.is_some() {
                Poll::Pending
            } else {
                // All copies of EArc dropped - no more events can be sent, stop processing
                Poll::Ready(None)
            }
        }
    }
    fn retranslate_event(&self, event: Arc<EventBox>) {
        self.subscribers.write().unwrap().send_event(event)
    }
}

impl Stream for SEArc {
    type Item = Arc<EventBox>;
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Arc<EventBox>>> {
        self.get_mut().poll_next(cx)
    }
}

impl<EVT: Send + Sync + 'static> EventStream<EVT> {
    pub fn new(earc: &EArc) -> Self {
        let event_queue = Arc::new(RwLock::new(EventBoxQueue::new()));
        let weak_event_queue = Arc::downgrade(&mut (event_queue.clone()));
        earc.subscribe(TypeId::of::<EVT>().into(), weak_event_queue);
        Self {
            event_queue,
            _phantom: PhantomData,
        }
    }
    fn poll_next(self: &mut Self, cx: &mut Context<'_>) -> Poll<Option<Event<EVT>>> {
        let mut event_queue = self.event_queue.write().unwrap();
        if event_queue.is_detached() {
            Poll::Ready(event_queue.get_event().map(|v| Event::new(v)))
        } else {
            if let Some(evt) = event_queue.get_event() {
                Poll::Ready(Some(Event::new(evt)))
            } else {
                event_queue.set_waker(cx.waker().clone());
                Poll::Pending
            }
        }
    }
}

impl<EVT: Send + Sync + Unpin + 'static> Stream for EventStream<EVT> {
    type Item = Event<EVT>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        self.get_mut().poll_next(cx)
    }
}
